{"path":"Supporting/Attachments/APIv2.pdf","text":"API V2 Consumer Types \u00005 mins) Supports both Copia and non-Copia users/services with generic as well as \"convenience\" endpoints Response parameters are predictable ( consistent?\u0000 Schema derived by caller's aud \u0000?\u0000 Scopes What resources are available What attributes are available in the response What is the default aud ? Examples user-read, user-write, service-read, service-write, site-admin-read, site-admin-write copia-service, Auth \u000020 mins) User-based ( current JWT schema) HS256 Uses authorization permissions for the User's role - aud Service account (public/priv ate key w/ expiration) RS256 Uses service scope and is restricted to Customer and its children Rate limiting \u00002 mins) (planned but not MVP\u0000 Let's hold space for this in our implementation PubSub \u000020 mins) Supplements existing \"convenience\", and service-centric Topics with Topics that are scoped to Customer & Model. Customer messages should only fire if the Customer's publish Flag is set for a model(s) Model messages should only fire if Publishable AbstractClass is implemented. \u0000K evin mentioned this might be implemented as Dynamo Streams) Payload should contain The same parameters that an API call would. Diff for Updates. Data Access Layer ( DAL) \u000020 mins) Ease onboarding Graph support becomes much cleaner to implement Consistent getter/setter behavior e.g. Manages Relationships âž¡ DAL Relationships Defines relationships between instances so that the building of those relationships can be handled automatically by whatever mechanism we choose ( e.g., Graph) If <Model>.create({schema}) contains parentId, we can: create a parent/child relationship in Graph. As well as update any ephemeral maps we have for the Dynamo relationship <Model>.find(id, type) // type (pk,sk), composite, gsi, class (class would be empty args) <Model>.create({schema}) <Model>.update(id, {}) <Model>.delete(id) // runs recursive destroy, with validations <Model>.destroy(id) // runs atomic destroy, no validations <Model>.move(id, dest_id) <Model>.dynamoQuery(query) //runs a raw dynamo query class CustomerLocation:DataAccessLayer { const Attributes = [active, ] const RequiredAttributes = [pk, sk, ] override fun create(params) { if (params.contains(\"Address\")) { Address.create(params.address) } } } CustomerLocation.find(\"clo_\", includes: [Addresses, Pickups])","libVersion":"0.3.2","langs":""}